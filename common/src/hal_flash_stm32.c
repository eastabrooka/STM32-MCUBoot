// Generated by GPT. If it looks wrong, It probably is. 

// hal_flash_stm32.c

#include "flash_map_backend/flash_map_backend.h"
#include "stm32l4xx_hal.h"

// Dummy flash area descriptions
// You can adjust these according to your bootloader layout
static const struct flash_area flash_map[] = {
    {
        .fa_id = 0,  // Primary slot
        .fa_device_id = 0,
        .fa_off = 0x08020000,   // <-- Your app start
        .fa_size = 256 * 1024,  // Example: 256KB for your app
    },
    {
        .fa_id = 1,  // Secondary slot
        .fa_device_id = 0,
        .fa_off = 0x08060000,   // <-- Update image storage
        .fa_size = 256 * 1024,  // Same size as primary
    },
    {
        .fa_id = 2,  // Scratch area
        .fa_device_id = 0,
        .fa_off = 0x080A0000,   // <-- scratch area for swapping
        .fa_size = 32 * 1024,   // Example: 32KB
    },
};


#define FLASH_MAP_ENTRIES (sizeof(flash_map) / sizeof(flash_map[0]))

int flash_area_open(uint8_t id, const struct flash_area **fa)
{
    for (int i = 0; i < FLASH_MAP_ENTRIES; i++) {
        if (flash_map[i].fa_id == id) {
            *fa = &flash_map[i];
            return 0;
        }
    }
    return -1; // Not found
}

void flash_area_close(const struct flash_area *fa)
{
    (void)fa;
}

int flash_area_read(const struct flash_area *fa, uint32_t off, void *dst, uint32_t len)
{
    if (off + len > fa->fa_size) {
        return -1;
    }

    memcpy(dst, (const void *)(fa->fa_off + off), len);
    return 0;
}

int flash_area_write(const struct flash_area *fa, uint32_t off, const void *src, uint32_t len)
{
    if (off + len > fa->fa_size) {
        return -1;
    }

    HAL_FLASH_Unlock();

    uint32_t addr = fa->fa_off + off;
    const uint8_t *data = (const uint8_t *)src;

    for (uint32_t i = 0; i < len; i += 1) {
        if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_BYTE, addr + i, data[i]) != HAL_OK) {
            HAL_FLASH_Lock();
            return -1;
        }
    }

    HAL_FLASH_Lock();
    return 0;
}

int flash_area_erase(const struct flash_area *fa, uint32_t off, uint32_t len)
{
    if (off + len > fa->fa_size) {
        return -1;
    }

    HAL_FLASH_Unlock();

    FLASH_EraseInitTypeDef erase_init;
    uint32_t page_error;
    uint32_t first_page = (fa->fa_off + off) / FLASH_PAGE_SIZE;
    uint32_t num_pages = (len + FLASH_PAGE_SIZE - 1) / FLASH_PAGE_SIZE;

    erase_init.TypeErase = FLASH_TYPEERASE_PAGES;
    erase_init.Page = first_page;
    erase_init.NbPages = num_pages;
    erase_init.Banks = FLASH_BANK_1; // You might need to adjust for dual-bank devices

    if (HAL_FLASHEx_Erase(&erase_init, &page_error) != HAL_OK) {
        HAL_FLASH_Lock();
        return -1;
    }

    HAL_FLASH_Lock();
    return 0;
}

uint32_t flash_area_get_off(const struct flash_area *fa)
{
    return fa->fa_off;
}

uint32_t flash_area_get_size(const struct flash_area *fa)
{
    return fa->fa_size;
}

int flash_area_get_sectors(int fa_id, uint32_t *count, struct flash_sector *sectors)
{
    const struct flash_area *fa;
    if (flash_area_open(fa_id, &fa) != 0) {
        return -1;
    }

    uint32_t sector_size = FLASH_PAGE_SIZE;
    uint32_t num_sectors = fa->fa_size / sector_size;

    for (uint32_t i = 0; i < num_sectors; i++) {
        sectors[i].fs_off = i * sector_size;
        sectors[i].fs_size = sector_size;
    }

    *count = num_sectors;
    return 0;
}

uint8_t flash_area_get_device_id(const struct flash_area *fa)
{
    return fa->fa_device_id;
}

uint32_t flash_sector_get_off(const struct flash_sector *fs)
{
    return fs->fs_off;
}

uint32_t flash_sector_get_size(const struct flash_sector *fs)
{
    return fs->fs_size;
}
